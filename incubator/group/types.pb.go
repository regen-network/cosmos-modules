// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types.proto

package group

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Choice int32

const (
	Choice_UNKNOWN Choice = 0
	Choice_NO      Choice = 1
	Choice_YES     Choice = 2
	Choice_ABSTAIN Choice = 3
	Choice_VETO    Choice = 4
)

var Choice_name = map[int32]string{
	0: "UNKNOWN",
	1: "NO",
	2: "YES",
	3: "ABSTAIN",
	4: "VETO",
}

var Choice_value = map[string]int32{
	"UNKNOWN": 0,
	"NO":      1,
	"YES":     2,
	"ABSTAIN": 3,
	"VETO":    4,
}

func (x Choice) String() string {
	return proto.EnumName(Choice_name, int32(x))
}

func (Choice) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{0}
}

type Msg struct {
	// Types that are valid to be assigned to Sum:
	//	*Msg_CreateGroup
	//	*Msg_UpdateGroupMembers
	//	*Msg_UpdateGroupAdmin
	//	*Msg_UpdateGroupComment
	//	*Msg_CreateGroupAccount
	//	*Msg_UpdateGroupAccountAdmin
	//	*Msg_UpdateGroupAccountDecisionPolicy
	//	*Msg_UpdateGroupAccountComment
	//	*Msg_Vote
	//	*Msg_Exec
	Sum isMsg_Sum `protobuf_oneof:"sum"`
}

func (m *Msg) Reset()         { *m = Msg{} }
func (m *Msg) String() string { return proto.CompactTextString(m) }
func (*Msg) ProtoMessage()    {}
func (*Msg) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{0}
}
func (m *Msg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Msg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Msg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Msg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Msg.Merge(m, src)
}
func (m *Msg) XXX_Size() int {
	return m.Size()
}
func (m *Msg) XXX_DiscardUnknown() {
	xxx_messageInfo_Msg.DiscardUnknown(m)
}

var xxx_messageInfo_Msg proto.InternalMessageInfo

type isMsg_Sum interface {
	isMsg_Sum()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Msg_CreateGroup struct {
	CreateGroup *MsgCreateGroup `protobuf:"bytes,1,opt,name=create_group,json=createGroup,proto3,oneof" json:"create_group,omitempty"`
}
type Msg_UpdateGroupMembers struct {
	UpdateGroupMembers *MsgUpdateGroupMembers `protobuf:"bytes,2,opt,name=update_group_members,json=updateGroupMembers,proto3,oneof" json:"update_group_members,omitempty"`
}
type Msg_UpdateGroupAdmin struct {
	UpdateGroupAdmin *MsgUpdateGroupAdmin `protobuf:"bytes,3,opt,name=update_group_admin,json=updateGroupAdmin,proto3,oneof" json:"update_group_admin,omitempty"`
}
type Msg_UpdateGroupComment struct {
	UpdateGroupComment *MsgUpdateGroupComment `protobuf:"bytes,4,opt,name=update_group_comment,json=updateGroupComment,proto3,oneof" json:"update_group_comment,omitempty"`
}
type Msg_CreateGroupAccount struct {
	CreateGroupAccount *MsgCreateGroupAccountStd `protobuf:"bytes,5,opt,name=create_group_account,json=createGroupAccount,proto3,oneof" json:"create_group_account,omitempty"`
}
type Msg_UpdateGroupAccountAdmin struct {
	UpdateGroupAccountAdmin *MsgUpdateGroupAccountAdmin `protobuf:"bytes,6,opt,name=update_group_account_admin,json=updateGroupAccountAdmin,proto3,oneof" json:"update_group_account_admin,omitempty"`
}
type Msg_UpdateGroupAccountDecisionPolicy struct {
	UpdateGroupAccountDecisionPolicy *MsgUpdateGroupAccountDecisionPolicyStd `protobuf:"bytes,7,opt,name=update_group_account_decision_policy,json=updateGroupAccountDecisionPolicy,proto3,oneof" json:"update_group_account_decision_policy,omitempty"`
}
type Msg_UpdateGroupAccountComment struct {
	UpdateGroupAccountComment *MsgUpdateGroupAccountComment `protobuf:"bytes,8,opt,name=update_group_account_comment,json=updateGroupAccountComment,proto3,oneof" json:"update_group_account_comment,omitempty"`
}
type Msg_Vote struct {
	Vote *MsgVote `protobuf:"bytes,9,opt,name=vote,proto3,oneof" json:"vote,omitempty"`
}
type Msg_Exec struct {
	Exec *MsgExec `protobuf:"bytes,10,opt,name=exec,proto3,oneof" json:"exec,omitempty"`
}

func (*Msg_CreateGroup) isMsg_Sum()                      {}
func (*Msg_UpdateGroupMembers) isMsg_Sum()               {}
func (*Msg_UpdateGroupAdmin) isMsg_Sum()                 {}
func (*Msg_UpdateGroupComment) isMsg_Sum()               {}
func (*Msg_CreateGroupAccount) isMsg_Sum()               {}
func (*Msg_UpdateGroupAccountAdmin) isMsg_Sum()          {}
func (*Msg_UpdateGroupAccountDecisionPolicy) isMsg_Sum() {}
func (*Msg_UpdateGroupAccountComment) isMsg_Sum()        {}
func (*Msg_Vote) isMsg_Sum()                             {}
func (*Msg_Exec) isMsg_Sum()                             {}

func (m *Msg) GetSum() isMsg_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (m *Msg) GetCreateGroup() *MsgCreateGroup {
	if x, ok := m.GetSum().(*Msg_CreateGroup); ok {
		return x.CreateGroup
	}
	return nil
}

func (m *Msg) GetUpdateGroupMembers() *MsgUpdateGroupMembers {
	if x, ok := m.GetSum().(*Msg_UpdateGroupMembers); ok {
		return x.UpdateGroupMembers
	}
	return nil
}

func (m *Msg) GetUpdateGroupAdmin() *MsgUpdateGroupAdmin {
	if x, ok := m.GetSum().(*Msg_UpdateGroupAdmin); ok {
		return x.UpdateGroupAdmin
	}
	return nil
}

func (m *Msg) GetUpdateGroupComment() *MsgUpdateGroupComment {
	if x, ok := m.GetSum().(*Msg_UpdateGroupComment); ok {
		return x.UpdateGroupComment
	}
	return nil
}

func (m *Msg) GetCreateGroupAccount() *MsgCreateGroupAccountStd {
	if x, ok := m.GetSum().(*Msg_CreateGroupAccount); ok {
		return x.CreateGroupAccount
	}
	return nil
}

func (m *Msg) GetUpdateGroupAccountAdmin() *MsgUpdateGroupAccountAdmin {
	if x, ok := m.GetSum().(*Msg_UpdateGroupAccountAdmin); ok {
		return x.UpdateGroupAccountAdmin
	}
	return nil
}

func (m *Msg) GetUpdateGroupAccountDecisionPolicy() *MsgUpdateGroupAccountDecisionPolicyStd {
	if x, ok := m.GetSum().(*Msg_UpdateGroupAccountDecisionPolicy); ok {
		return x.UpdateGroupAccountDecisionPolicy
	}
	return nil
}

func (m *Msg) GetUpdateGroupAccountComment() *MsgUpdateGroupAccountComment {
	if x, ok := m.GetSum().(*Msg_UpdateGroupAccountComment); ok {
		return x.UpdateGroupAccountComment
	}
	return nil
}

func (m *Msg) GetVote() *MsgVote {
	if x, ok := m.GetSum().(*Msg_Vote); ok {
		return x.Vote
	}
	return nil
}

func (m *Msg) GetExec() *MsgExec {
	if x, ok := m.GetSum().(*Msg_Exec); ok {
		return x.Exec
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Msg) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Msg_CreateGroup)(nil),
		(*Msg_UpdateGroupMembers)(nil),
		(*Msg_UpdateGroupAdmin)(nil),
		(*Msg_UpdateGroupComment)(nil),
		(*Msg_CreateGroupAccount)(nil),
		(*Msg_UpdateGroupAccountAdmin)(nil),
		(*Msg_UpdateGroupAccountDecisionPolicy)(nil),
		(*Msg_UpdateGroupAccountComment)(nil),
		(*Msg_Vote)(nil),
		(*Msg_Exec)(nil),
	}
}

type MsgCreateGroup struct {
	Admin   github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=admin,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"admin,omitempty"`
	Members []*Member                                     `protobuf:"bytes,2,rep,name=members,proto3" json:"members,omitempty"`
	Comment string                                        `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *MsgCreateGroup) Reset()         { *m = MsgCreateGroup{} }
func (m *MsgCreateGroup) String() string { return proto.CompactTextString(m) }
func (*MsgCreateGroup) ProtoMessage()    {}
func (*MsgCreateGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{1}
}
func (m *MsgCreateGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateGroup.Merge(m, src)
}
func (m *MsgCreateGroup) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateGroup.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateGroup proto.InternalMessageInfo

func (m *MsgCreateGroup) GetAdmin() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *MsgCreateGroup) GetMembers() []*Member {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *MsgCreateGroup) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

type MsgUpdateGroupMembers struct {
	Admin         github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=admin,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"admin,omitempty"`
	Group         GroupID                                       `protobuf:"varint,2,opt,name=group,proto3,casttype=GroupID" json:"group,omitempty"`
	MemberUpdates []*Member                                     `protobuf:"bytes,3,rep,name=member_updates,json=memberUpdates,proto3" json:"member_updates,omitempty"`
}

func (m *MsgUpdateGroupMembers) Reset()         { *m = MsgUpdateGroupMembers{} }
func (m *MsgUpdateGroupMembers) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateGroupMembers) ProtoMessage()    {}
func (*MsgUpdateGroupMembers) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{2}
}
func (m *MsgUpdateGroupMembers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateGroupMembers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateGroupMembers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateGroupMembers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateGroupMembers.Merge(m, src)
}
func (m *MsgUpdateGroupMembers) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateGroupMembers) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateGroupMembers.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateGroupMembers proto.InternalMessageInfo

func (m *MsgUpdateGroupMembers) GetAdmin() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *MsgUpdateGroupMembers) GetGroup() GroupID {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *MsgUpdateGroupMembers) GetMemberUpdates() []*Member {
	if m != nil {
		return m.MemberUpdates
	}
	return nil
}

type MsgUpdateGroupAdmin struct {
	Admin    github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=admin,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"admin,omitempty"`
	Group    GroupID                                       `protobuf:"varint,2,opt,name=group,proto3,casttype=GroupID" json:"group,omitempty"`
	NewAdmin github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,3,opt,name=new_admin,json=newAdmin,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"new_admin,omitempty"`
}

func (m *MsgUpdateGroupAdmin) Reset()         { *m = MsgUpdateGroupAdmin{} }
func (m *MsgUpdateGroupAdmin) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateGroupAdmin) ProtoMessage()    {}
func (*MsgUpdateGroupAdmin) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{3}
}
func (m *MsgUpdateGroupAdmin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateGroupAdmin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateGroupAdmin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateGroupAdmin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateGroupAdmin.Merge(m, src)
}
func (m *MsgUpdateGroupAdmin) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateGroupAdmin) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateGroupAdmin.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateGroupAdmin proto.InternalMessageInfo

func (m *MsgUpdateGroupAdmin) GetAdmin() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *MsgUpdateGroupAdmin) GetGroup() GroupID {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *MsgUpdateGroupAdmin) GetNewAdmin() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.NewAdmin
	}
	return nil
}

type MsgUpdateGroupComment struct {
	Admin   github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=admin,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"admin,omitempty"`
	Group   GroupID                                       `protobuf:"varint,2,opt,name=group,proto3,casttype=GroupID" json:"group,omitempty"`
	Comment string                                        `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *MsgUpdateGroupComment) Reset()         { *m = MsgUpdateGroupComment{} }
func (m *MsgUpdateGroupComment) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateGroupComment) ProtoMessage()    {}
func (*MsgUpdateGroupComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{4}
}
func (m *MsgUpdateGroupComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateGroupComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateGroupComment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateGroupComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateGroupComment.Merge(m, src)
}
func (m *MsgUpdateGroupComment) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateGroupComment) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateGroupComment.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateGroupComment proto.InternalMessageInfo

func (m *MsgUpdateGroupComment) GetAdmin() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *MsgUpdateGroupComment) GetGroup() GroupID {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *MsgUpdateGroupComment) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

type Member struct {
	Address github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=address,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"address,omitempty"`
	Power   *github_com_cosmos_cosmos_sdk_types.Dec       `protobuf:"bytes,2,opt,name=power,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"power,omitempty"`
	Comment string                                        `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{5}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Member) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

type MsgCreateGroupAccountBase struct {
	Admin   github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=admin,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"admin,omitempty"`
	Group   GroupID                                       `protobuf:"varint,2,opt,name=group,proto3,casttype=GroupID" json:"group,omitempty"`
	Comment string                                        `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *MsgCreateGroupAccountBase) Reset()         { *m = MsgCreateGroupAccountBase{} }
func (m *MsgCreateGroupAccountBase) String() string { return proto.CompactTextString(m) }
func (*MsgCreateGroupAccountBase) ProtoMessage()    {}
func (*MsgCreateGroupAccountBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{6}
}
func (m *MsgCreateGroupAccountBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateGroupAccountBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateGroupAccountBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateGroupAccountBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateGroupAccountBase.Merge(m, src)
}
func (m *MsgCreateGroupAccountBase) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateGroupAccountBase) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateGroupAccountBase.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateGroupAccountBase proto.InternalMessageInfo

func (m *MsgCreateGroupAccountBase) GetAdmin() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *MsgCreateGroupAccountBase) GetGroup() GroupID {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *MsgCreateGroupAccountBase) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

// MsgCreateGroupAccountStd creates a group account using one of the members of StdDecisionPolicy. Apps can
// create their own create account msg that supports custom DecisionPolicy's using MsgCreateGroupAccountBase as
// starting point
type MsgCreateGroupAccountStd struct {
	Base           *MsgCreateGroupAccountBase `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	DecisionPolicy *StdDecisionPolicy         `protobuf:"bytes,2,opt,name=decision_policy,json=decisionPolicy,proto3" json:"decision_policy,omitempty"`
}

func (m *MsgCreateGroupAccountStd) Reset()         { *m = MsgCreateGroupAccountStd{} }
func (m *MsgCreateGroupAccountStd) String() string { return proto.CompactTextString(m) }
func (*MsgCreateGroupAccountStd) ProtoMessage()    {}
func (*MsgCreateGroupAccountStd) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{7}
}
func (m *MsgCreateGroupAccountStd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateGroupAccountStd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateGroupAccountStd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateGroupAccountStd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateGroupAccountStd.Merge(m, src)
}
func (m *MsgCreateGroupAccountStd) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateGroupAccountStd) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateGroupAccountStd.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateGroupAccountStd proto.InternalMessageInfo

func (m *MsgCreateGroupAccountStd) GetBase() *MsgCreateGroupAccountBase {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *MsgCreateGroupAccountStd) GetDecisionPolicy() *StdDecisionPolicy {
	if m != nil {
		return m.DecisionPolicy
	}
	return nil
}

type MsgUpdateGroupAccountAdmin struct {
	Admin       github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=admin,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"admin,omitempty"`
	GroupAcount github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=group_acount,json=groupAcount,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"group_acount,omitempty"`
	NewAdmin    github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,3,opt,name=new_admin,json=newAdmin,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"new_admin,omitempty"`
}

func (m *MsgUpdateGroupAccountAdmin) Reset()         { *m = MsgUpdateGroupAccountAdmin{} }
func (m *MsgUpdateGroupAccountAdmin) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateGroupAccountAdmin) ProtoMessage()    {}
func (*MsgUpdateGroupAccountAdmin) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{8}
}
func (m *MsgUpdateGroupAccountAdmin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateGroupAccountAdmin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateGroupAccountAdmin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateGroupAccountAdmin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateGroupAccountAdmin.Merge(m, src)
}
func (m *MsgUpdateGroupAccountAdmin) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateGroupAccountAdmin) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateGroupAccountAdmin.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateGroupAccountAdmin proto.InternalMessageInfo

func (m *MsgUpdateGroupAccountAdmin) GetAdmin() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *MsgUpdateGroupAccountAdmin) GetGroupAcount() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.GroupAcount
	}
	return nil
}

func (m *MsgUpdateGroupAccountAdmin) GetNewAdmin() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.NewAdmin
	}
	return nil
}

type MsgUpdateGroupAccountBase struct {
	Admin github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=admin,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"admin,omitempty"`
	Group GroupID                                       `protobuf:"varint,2,opt,name=group,proto3,casttype=GroupID" json:"group,omitempty"`
}

func (m *MsgUpdateGroupAccountBase) Reset()         { *m = MsgUpdateGroupAccountBase{} }
func (m *MsgUpdateGroupAccountBase) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateGroupAccountBase) ProtoMessage()    {}
func (*MsgUpdateGroupAccountBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{9}
}
func (m *MsgUpdateGroupAccountBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateGroupAccountBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateGroupAccountBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateGroupAccountBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateGroupAccountBase.Merge(m, src)
}
func (m *MsgUpdateGroupAccountBase) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateGroupAccountBase) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateGroupAccountBase.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateGroupAccountBase proto.InternalMessageInfo

func (m *MsgUpdateGroupAccountBase) GetAdmin() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *MsgUpdateGroupAccountBase) GetGroup() GroupID {
	if m != nil {
		return m.Group
	}
	return 0
}

// MsgCreateGroupAccountStd allows a group account decision policy to be updated to a member of StdDecisionPolicy, can
// be overridden to support custom DecisionPolicy's by apps.
type MsgUpdateGroupAccountDecisionPolicyStd struct {
	Base           *MsgUpdateGroupAccountBase `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	DecisionPolicy *StdDecisionPolicy         `protobuf:"bytes,3,opt,name=decision_policy,json=decisionPolicy,proto3" json:"decision_policy,omitempty"`
}

func (m *MsgUpdateGroupAccountDecisionPolicyStd) Reset() {
	*m = MsgUpdateGroupAccountDecisionPolicyStd{}
}
func (m *MsgUpdateGroupAccountDecisionPolicyStd) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateGroupAccountDecisionPolicyStd) ProtoMessage()    {}
func (*MsgUpdateGroupAccountDecisionPolicyStd) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{10}
}
func (m *MsgUpdateGroupAccountDecisionPolicyStd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateGroupAccountDecisionPolicyStd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateGroupAccountDecisionPolicyStd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateGroupAccountDecisionPolicyStd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateGroupAccountDecisionPolicyStd.Merge(m, src)
}
func (m *MsgUpdateGroupAccountDecisionPolicyStd) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateGroupAccountDecisionPolicyStd) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateGroupAccountDecisionPolicyStd.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateGroupAccountDecisionPolicyStd proto.InternalMessageInfo

func (m *MsgUpdateGroupAccountDecisionPolicyStd) GetBase() *MsgUpdateGroupAccountBase {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *MsgUpdateGroupAccountDecisionPolicyStd) GetDecisionPolicy() *StdDecisionPolicy {
	if m != nil {
		return m.DecisionPolicy
	}
	return nil
}

type MsgUpdateGroupAccountComment struct {
	Admin       github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=admin,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"admin,omitempty"`
	GroupAcount github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=group_acount,json=groupAcount,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"group_acount,omitempty"`
	Comment     string                                        `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *MsgUpdateGroupAccountComment) Reset()         { *m = MsgUpdateGroupAccountComment{} }
func (m *MsgUpdateGroupAccountComment) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateGroupAccountComment) ProtoMessage()    {}
func (*MsgUpdateGroupAccountComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{11}
}
func (m *MsgUpdateGroupAccountComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateGroupAccountComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateGroupAccountComment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateGroupAccountComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateGroupAccountComment.Merge(m, src)
}
func (m *MsgUpdateGroupAccountComment) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateGroupAccountComment) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateGroupAccountComment.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateGroupAccountComment proto.InternalMessageInfo

func (m *MsgUpdateGroupAccountComment) GetAdmin() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *MsgUpdateGroupAccountComment) GetGroupAcount() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.GroupAcount
	}
	return nil
}

func (m *MsgUpdateGroupAccountComment) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

// StdDecisionPolicy is a set of standard decision policies that can be used by zones that do not implement custom
// DecisionPolicy types. Apps can start with StdDecisionPolicy and later add custom DecisionPolicy's by creating
// a MyAppDecisionPolicy and registering that with the group module codec. In order to be backwards compatible,
// MyAppDecisionPolicy should include all the existing StdDecisionPolicy types with the same field number and then
// add custom DecisionPolicy types afterwards.
type StdDecisionPolicy struct {
	// Types that are valid to be assigned to Sum:
	//	*StdDecisionPolicy_Threshold
	Sum isStdDecisionPolicy_Sum `protobuf_oneof:"sum"`
}

func (m *StdDecisionPolicy) Reset()         { *m = StdDecisionPolicy{} }
func (m *StdDecisionPolicy) String() string { return proto.CompactTextString(m) }
func (*StdDecisionPolicy) ProtoMessage()    {}
func (*StdDecisionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{12}
}
func (m *StdDecisionPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StdDecisionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StdDecisionPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StdDecisionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StdDecisionPolicy.Merge(m, src)
}
func (m *StdDecisionPolicy) XXX_Size() int {
	return m.Size()
}
func (m *StdDecisionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_StdDecisionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_StdDecisionPolicy proto.InternalMessageInfo

type isStdDecisionPolicy_Sum interface {
	isStdDecisionPolicy_Sum()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StdDecisionPolicy_Threshold struct {
	Threshold *ThresholdDecisionPolicy `protobuf:"bytes,1,opt,name=threshold,proto3,oneof" json:"threshold,omitempty"`
}

func (*StdDecisionPolicy_Threshold) isStdDecisionPolicy_Sum() {}

func (m *StdDecisionPolicy) GetSum() isStdDecisionPolicy_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (m *StdDecisionPolicy) GetThreshold() *ThresholdDecisionPolicy {
	if x, ok := m.GetSum().(*StdDecisionPolicy_Threshold); ok {
		return x.Threshold
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StdDecisionPolicy) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StdDecisionPolicy_Threshold)(nil),
	}
}

type ThresholdDecisionPolicy struct {
	Threshold       *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=threshold,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"threshold,omitempty"`
	MinVotingWindow *types.Duration                         `protobuf:"bytes,2,opt,name=min_voting_window,json=minVotingWindow,proto3" json:"min_voting_window,omitempty"`
	MaxVotingWindow *types.Duration                         `protobuf:"bytes,3,opt,name=max_voting_window,json=maxVotingWindow,proto3" json:"max_voting_window,omitempty"`
}

func (m *ThresholdDecisionPolicy) Reset()         { *m = ThresholdDecisionPolicy{} }
func (m *ThresholdDecisionPolicy) String() string { return proto.CompactTextString(m) }
func (*ThresholdDecisionPolicy) ProtoMessage()    {}
func (*ThresholdDecisionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{13}
}
func (m *ThresholdDecisionPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThresholdDecisionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThresholdDecisionPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThresholdDecisionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdDecisionPolicy.Merge(m, src)
}
func (m *ThresholdDecisionPolicy) XXX_Size() int {
	return m.Size()
}
func (m *ThresholdDecisionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdDecisionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdDecisionPolicy proto.InternalMessageInfo

func (m *ThresholdDecisionPolicy) GetMinVotingWindow() *types.Duration {
	if m != nil {
		return m.MinVotingWindow
	}
	return nil
}

func (m *ThresholdDecisionPolicy) GetMaxVotingWindow() *types.Duration {
	if m != nil {
		return m.MaxVotingWindow
	}
	return nil
}

// MsgProposeBase is the base propose msg that app should use to implement a MsgPropose type based
// on their app Msg type.
//
// Ex:
// message MsgPropose {
//   MsgProposeBase base = 1;
//   repeated MyAppMsg msgs = 2;
// }
type MsgProposeBase struct {
	GroupAccount github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=group_account,json=groupAccount,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"group_account,omitempty"`
	// Proposers signatures will be counted as yes votes
	Proposers []github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,rep,name=proposers,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"proposers,omitempty"`
	Comment   string                                          `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
	// ExecNow will attempt to execute the proposal immediately based on
	// the proposers signing the transaction
	ExecNow bool `protobuf:"varint,4,opt,name=exec_now,json=execNow,proto3" json:"exec_now,omitempty"`
}

func (m *MsgProposeBase) Reset()         { *m = MsgProposeBase{} }
func (m *MsgProposeBase) String() string { return proto.CompactTextString(m) }
func (*MsgProposeBase) ProtoMessage()    {}
func (*MsgProposeBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{14}
}
func (m *MsgProposeBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposeBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposeBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposeBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposeBase.Merge(m, src)
}
func (m *MsgProposeBase) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposeBase) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposeBase.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposeBase proto.InternalMessageInfo

func (m *MsgProposeBase) GetGroupAccount() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.GroupAccount
	}
	return nil
}

func (m *MsgProposeBase) GetProposers() []github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Proposers
	}
	return nil
}

func (m *MsgProposeBase) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *MsgProposeBase) GetExecNow() bool {
	if m != nil {
		return m.ExecNow
	}
	return false
}

type MsgVote struct {
	Proposal ProposalID                                      `protobuf:"varint,1,opt,name=proposal,proto3,casttype=ProposalID" json:"proposal,omitempty"`
	Voters   []github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,rep,name=voters,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"voters,omitempty"`
	Choice   Choice                                          `protobuf:"varint,3,opt,name=choice,proto3,enum=cosmos_modules.incubator.group.v1_alpha.Choice" json:"choice,omitempty"`
	Comment  string                                          `protobuf:"bytes,4,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *MsgVote) Reset()         { *m = MsgVote{} }
func (m *MsgVote) String() string { return proto.CompactTextString(m) }
func (*MsgVote) ProtoMessage()    {}
func (*MsgVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{15}
}
func (m *MsgVote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgVote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgVote.Merge(m, src)
}
func (m *MsgVote) XXX_Size() int {
	return m.Size()
}
func (m *MsgVote) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgVote.DiscardUnknown(m)
}

var xxx_messageInfo_MsgVote proto.InternalMessageInfo

func (m *MsgVote) GetProposal() ProposalID {
	if m != nil {
		return m.Proposal
	}
	return 0
}

func (m *MsgVote) GetVoters() []github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Voters
	}
	return nil
}

func (m *MsgVote) GetChoice() Choice {
	if m != nil {
		return m.Choice
	}
	return Choice_UNKNOWN
}

func (m *MsgVote) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

type MsgExec struct {
	Proposal ProposalID                                    `protobuf:"varint,1,opt,name=proposal,proto3,casttype=ProposalID" json:"proposal,omitempty"`
	Signer   github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=signer,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"signer,omitempty"`
}

func (m *MsgExec) Reset()         { *m = MsgExec{} }
func (m *MsgExec) String() string { return proto.CompactTextString(m) }
func (*MsgExec) ProtoMessage()    {}
func (*MsgExec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{16}
}
func (m *MsgExec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgExec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgExec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgExec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgExec.Merge(m, src)
}
func (m *MsgExec) XXX_Size() int {
	return m.Size()
}
func (m *MsgExec) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgExec.DiscardUnknown(m)
}

var xxx_messageInfo_MsgExec proto.InternalMessageInfo

func (m *MsgExec) GetProposal() ProposalID {
	if m != nil {
		return m.Proposal
	}
	return 0
}

func (m *MsgExec) GetSigner() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Signer
	}
	return nil
}

type GroupMetadata struct {
	Group   GroupID                                       `protobuf:"varint,1,opt,name=group,proto3,casttype=GroupID" json:"group,omitempty"`
	Admin   github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=admin,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"admin,omitempty"`
	Comment string                                        `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
	// version is used to track changes to a group's membership structure that
	// would break existing proposals. Whenever any members power is changed,
	// or any member is added or removed this version is incremented and will
	// cause proposals based on older versions of this group to fail
	Version uint64 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *GroupMetadata) Reset()         { *m = GroupMetadata{} }
func (m *GroupMetadata) String() string { return proto.CompactTextString(m) }
func (*GroupMetadata) ProtoMessage()    {}
func (*GroupMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{17}
}
func (m *GroupMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMetadata.Merge(m, src)
}
func (m *GroupMetadata) XXX_Size() int {
	return m.Size()
}
func (m *GroupMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMetadata proto.InternalMessageInfo

func (m *GroupMetadata) GetGroup() GroupID {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *GroupMetadata) GetAdmin() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *GroupMetadata) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *GroupMetadata) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type GroupMember struct {
	Group  GroupID                                       `protobuf:"varint,1,opt,name=group,proto3,casttype=GroupID" json:"group,omitempty"`
	Member github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=member,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"member,omitempty"`
	Weight *github_com_cosmos_cosmos_sdk_types.Dec       `protobuf:"bytes,3,opt,name=weight,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"weight,omitempty"`
}

func (m *GroupMember) Reset()         { *m = GroupMember{} }
func (m *GroupMember) String() string { return proto.CompactTextString(m) }
func (*GroupMember) ProtoMessage()    {}
func (*GroupMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{18}
}
func (m *GroupMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMember.Merge(m, src)
}
func (m *GroupMember) XXX_Size() int {
	return m.Size()
}
func (m *GroupMember) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMember.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMember proto.InternalMessageInfo

func (m *GroupMember) GetGroup() GroupID {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *GroupMember) GetMember() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Member
	}
	return nil
}

// GroupAccountMetadataBase is the base message that app's should use to specify group account metadata based on the
// DecisionPolicy's they support.
//
// Ex:
// message MyAppGroupAccountMetadata {
//     GroupAccountMetadataBase base = 1;
//     MyAppDecisionPolicy decision_policy = 2;
// }
//
// App's which do not implement custom DecisionPolicy's can use StdGroupAccountMetadata.
type GroupAccountMetadataBase struct {
	GroupAccount github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=group_account,json=groupAccount,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"group_account,omitempty"`
	Group        GroupID                                       `protobuf:"varint,2,opt,name=group,proto3,casttype=GroupID" json:"group,omitempty"`
	Admin        github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,3,opt,name=admin,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"admin,omitempty"`
	Comment      string                                        `protobuf:"bytes,4,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *GroupAccountMetadataBase) Reset()         { *m = GroupAccountMetadataBase{} }
func (m *GroupAccountMetadataBase) String() string { return proto.CompactTextString(m) }
func (*GroupAccountMetadataBase) ProtoMessage()    {}
func (*GroupAccountMetadataBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{19}
}
func (m *GroupAccountMetadataBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupAccountMetadataBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupAccountMetadataBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupAccountMetadataBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupAccountMetadataBase.Merge(m, src)
}
func (m *GroupAccountMetadataBase) XXX_Size() int {
	return m.Size()
}
func (m *GroupAccountMetadataBase) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupAccountMetadataBase.DiscardUnknown(m)
}

var xxx_messageInfo_GroupAccountMetadataBase proto.InternalMessageInfo

func (m *GroupAccountMetadataBase) GetGroupAccount() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.GroupAccount
	}
	return nil
}

func (m *GroupAccountMetadataBase) GetGroup() GroupID {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *GroupAccountMetadataBase) GetAdmin() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Admin
	}
	return nil
}

func (m *GroupAccountMetadataBase) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

// StdGroupAccountMetadata is a default group account metadata type to be used by apps which do not implement custom
// DecisionPolicy's.
type StdGroupAccountMetadata struct {
	Base           *GroupAccountMetadataBase `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	DecisionPolicy *StdDecisionPolicy        `protobuf:"bytes,2,opt,name=decision_policy,json=decisionPolicy,proto3" json:"decision_policy,omitempty"`
}

func (m *StdGroupAccountMetadata) Reset()         { *m = StdGroupAccountMetadata{} }
func (m *StdGroupAccountMetadata) String() string { return proto.CompactTextString(m) }
func (*StdGroupAccountMetadata) ProtoMessage()    {}
func (*StdGroupAccountMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{20}
}
func (m *StdGroupAccountMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StdGroupAccountMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StdGroupAccountMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StdGroupAccountMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StdGroupAccountMetadata.Merge(m, src)
}
func (m *StdGroupAccountMetadata) XXX_Size() int {
	return m.Size()
}
func (m *StdGroupAccountMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_StdGroupAccountMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_StdGroupAccountMetadata proto.InternalMessageInfo

func (m *StdGroupAccountMetadata) GetBase() *GroupAccountMetadataBase {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *StdGroupAccountMetadata) GetDecisionPolicy() *StdDecisionPolicy {
	if m != nil {
		return m.DecisionPolicy
	}
	return nil
}

// ProposalBase is the base proposal type that app should use to implement a Proposal type based
// on their app Msg type.
//
// Ex:
// message MyAppProposal {
//   ProposalBase base = 1;
//   repeated MyAppMsg msgs = 2;
// }
type ProposalBase struct {
	GroupAccount github_com_cosmos_cosmos_sdk_types.AccAddress   `protobuf:"bytes,1,opt,name=group_account,json=groupAccount,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"group_account,omitempty"`
	Comment      string                                          `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
	Proposers    []github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,3,rep,name=proposers,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"proposers,omitempty"`
	SubmittedAt  *types.Timestamp                                `protobuf:"bytes,4,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at,omitempty"`
	// GroupVersion tracks the version of the group that this proposal corresponds to. When group membership is changed
	// existing proposals for prior group versions will become invalid.
	GroupVersion uint64 `protobuf:"varint,5,opt,name=group_version,json=groupVersion,proto3" json:"group_version,omitempty"`
}

func (m *ProposalBase) Reset()         { *m = ProposalBase{} }
func (m *ProposalBase) String() string { return proto.CompactTextString(m) }
func (*ProposalBase) ProtoMessage()    {}
func (*ProposalBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{21}
}
func (m *ProposalBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalBase.Merge(m, src)
}
func (m *ProposalBase) XXX_Size() int {
	return m.Size()
}
func (m *ProposalBase) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalBase.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalBase proto.InternalMessageInfo

func (m *ProposalBase) GetGroupAccount() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.GroupAccount
	}
	return nil
}

func (m *ProposalBase) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *ProposalBase) GetProposers() []github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Proposers
	}
	return nil
}

func (m *ProposalBase) GetSubmittedAt() *types.Timestamp {
	if m != nil {
		return m.SubmittedAt
	}
	return nil
}

func (m *ProposalBase) GetGroupVersion() uint64 {
	if m != nil {
		return m.GroupVersion
	}
	return 0
}

type Tally struct {
	YesCount     *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=yes_count,json=yesCount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"yes_count,omitempty"`
	NoCount      *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=no_count,json=noCount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"no_count,omitempty"`
	AbstainCount *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=abstain_count,json=abstainCount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"abstain_count,omitempty"`
	VetoCount    *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=veto_count,json=vetoCount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"veto_count,omitempty"`
}

func (m *Tally) Reset()         { *m = Tally{} }
func (m *Tally) String() string { return proto.CompactTextString(m) }
func (*Tally) ProtoMessage()    {}
func (*Tally) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{22}
}
func (m *Tally) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tally) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tally.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tally) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tally.Merge(m, src)
}
func (m *Tally) XXX_Size() int {
	return m.Size()
}
func (m *Tally) XXX_DiscardUnknown() {
	xxx_messageInfo_Tally.DiscardUnknown(m)
}

var xxx_messageInfo_Tally proto.InternalMessageInfo

type Vote struct {
	Proposal    ProposalID                                    `protobuf:"varint,1,opt,name=proposal,proto3,casttype=ProposalID" json:"proposal,omitempty"`
	Voter       github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=voter,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"voter,omitempty"`
	Choice      Choice                                        `protobuf:"varint,3,opt,name=choice,proto3,enum=cosmos_modules.incubator.group.v1_alpha.Choice" json:"choice,omitempty"`
	Comment     string                                        `protobuf:"bytes,4,opt,name=comment,proto3" json:"comment,omitempty"`
	SubmittedAt *types.Timestamp                              `protobuf:"bytes,5,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at,omitempty"`
}

func (m *Vote) Reset()         { *m = Vote{} }
func (m *Vote) String() string { return proto.CompactTextString(m) }
func (*Vote) ProtoMessage()    {}
func (*Vote) Descriptor() ([]byte, []int) {
	return fileDescriptor_d938547f84707355, []int{23}
}
func (m *Vote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vote.Merge(m, src)
}
func (m *Vote) XXX_Size() int {
	return m.Size()
}
func (m *Vote) XXX_DiscardUnknown() {
	xxx_messageInfo_Vote.DiscardUnknown(m)
}

var xxx_messageInfo_Vote proto.InternalMessageInfo

func (m *Vote) GetProposal() ProposalID {
	if m != nil {
		return m.Proposal
	}
	return 0
}

func (m *Vote) GetVoter() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Voter
	}
	return nil
}

func (m *Vote) GetChoice() Choice {
	if m != nil {
		return m.Choice
	}
	return Choice_UNKNOWN
}

func (m *Vote) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Vote) GetSubmittedAt() *types.Timestamp {
	if m != nil {
		return m.SubmittedAt
	}
	return nil
}

func init() {
	proto.RegisterEnum("cosmos_modules.incubator.group.v1_alpha.Choice", Choice_name, Choice_value)
	proto.RegisterType((*Msg)(nil), "cosmos_modules.incubator.group.v1_alpha.Msg")
	proto.RegisterType((*MsgCreateGroup)(nil), "cosmos_modules.incubator.group.v1_alpha.MsgCreateGroup")
	proto.RegisterType((*MsgUpdateGroupMembers)(nil), "cosmos_modules.incubator.group.v1_alpha.MsgUpdateGroupMembers")
	proto.RegisterType((*MsgUpdateGroupAdmin)(nil), "cosmos_modules.incubator.group.v1_alpha.MsgUpdateGroupAdmin")
	proto.RegisterType((*MsgUpdateGroupComment)(nil), "cosmos_modules.incubator.group.v1_alpha.MsgUpdateGroupComment")
	proto.RegisterType((*Member)(nil), "cosmos_modules.incubator.group.v1_alpha.Member")
	proto.RegisterType((*MsgCreateGroupAccountBase)(nil), "cosmos_modules.incubator.group.v1_alpha.MsgCreateGroupAccountBase")
	proto.RegisterType((*MsgCreateGroupAccountStd)(nil), "cosmos_modules.incubator.group.v1_alpha.MsgCreateGroupAccountStd")
	proto.RegisterType((*MsgUpdateGroupAccountAdmin)(nil), "cosmos_modules.incubator.group.v1_alpha.MsgUpdateGroupAccountAdmin")
	proto.RegisterType((*MsgUpdateGroupAccountBase)(nil), "cosmos_modules.incubator.group.v1_alpha.MsgUpdateGroupAccountBase")
	proto.RegisterType((*MsgUpdateGroupAccountDecisionPolicyStd)(nil), "cosmos_modules.incubator.group.v1_alpha.MsgUpdateGroupAccountDecisionPolicyStd")
	proto.RegisterType((*MsgUpdateGroupAccountComment)(nil), "cosmos_modules.incubator.group.v1_alpha.MsgUpdateGroupAccountComment")
	proto.RegisterType((*StdDecisionPolicy)(nil), "cosmos_modules.incubator.group.v1_alpha.StdDecisionPolicy")
	proto.RegisterType((*ThresholdDecisionPolicy)(nil), "cosmos_modules.incubator.group.v1_alpha.ThresholdDecisionPolicy")
	proto.RegisterType((*MsgProposeBase)(nil), "cosmos_modules.incubator.group.v1_alpha.MsgProposeBase")
	proto.RegisterType((*MsgVote)(nil), "cosmos_modules.incubator.group.v1_alpha.MsgVote")
	proto.RegisterType((*MsgExec)(nil), "cosmos_modules.incubator.group.v1_alpha.MsgExec")
	proto.RegisterType((*GroupMetadata)(nil), "cosmos_modules.incubator.group.v1_alpha.GroupMetadata")
	proto.RegisterType((*GroupMember)(nil), "cosmos_modules.incubator.group.v1_alpha.GroupMember")
	proto.RegisterType((*GroupAccountMetadataBase)(nil), "cosmos_modules.incubator.group.v1_alpha.GroupAccountMetadataBase")
	proto.RegisterType((*StdGroupAccountMetadata)(nil), "cosmos_modules.incubator.group.v1_alpha.StdGroupAccountMetadata")
	proto.RegisterType((*ProposalBase)(nil), "cosmos_modules.incubator.group.v1_alpha.ProposalBase")
	proto.RegisterType((*Tally)(nil), "cosmos_modules.incubator.group.v1_alpha.Tally")
	proto.RegisterType((*Vote)(nil), "cosmos_modules.incubator.group.v1_alpha.Vote")
}

func init() { proto.RegisterFile("types.proto", fileDescriptor_d938547f84707355) }

var fileDescriptor_d938547f84707355 = []byte{
	// 1403 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcb, 0x6f, 0x1b, 0x45,
	0x18, 0xf7, 0xfa, 0xed, 0xcf, 0x4e, 0x9a, 0x0e, 0x45, 0xdd, 0x44, 0x95, 0x53, 0x16, 0x54, 0x4a,
	0xa5, 0xda, 0xb4, 0x1c, 0x90, 0x10, 0x45, 0xb5, 0x9d, 0x90, 0x58, 0x55, 0x9d, 0x6a, 0x93, 0xba,
	0x02, 0x21, 0x2d, 0xeb, 0xdd, 0x61, 0xb3, 0xc2, 0xbb, 0x63, 0xed, 0xce, 0xc6, 0x89, 0xc4, 0x01,
	0x71, 0x01, 0x89, 0x0b, 0xff, 0x40, 0x0f, 0xfd, 0x0b, 0x10, 0x42, 0x5c, 0xe1, 0xca, 0xb1, 0x1c,
	0x50, 0x11, 0x48, 0x11, 0x6a, 0xc4, 0x15, 0x89, 0x1b, 0x2a, 0x17, 0xb4, 0x33, 0xbb, 0xf1, 0xbb,
	0xf5, 0xda, 0x69, 0xd4, 0x53, 0x32, 0x33, 0xfb, 0xfd, 0xbe, 0xc7, 0x7c, 0x8f, 0xdf, 0x18, 0xf2,
	0xf4, 0xa0, 0x83, 0xdd, 0x52, 0xc7, 0x21, 0x94, 0xa0, 0xd7, 0x35, 0xe2, 0x5a, 0xc4, 0x55, 0x2c,
	0xa2, 0x7b, 0x6d, 0xec, 0x96, 0x4c, 0x5b, 0xf3, 0x5a, 0x2a, 0x25, 0x4e, 0xc9, 0x70, 0x88, 0xd7,
	0x29, 0xed, 0x5d, 0x53, 0xd4, 0x76, 0x67, 0x57, 0x5d, 0x39, 0x67, 0x10, 0x83, 0x30, 0x99, 0xb2,
	0xff, 0x1f, 0x17, 0x5f, 0x29, 0x1a, 0x84, 0x18, 0x6d, 0x5c, 0x66, 0xab, 0x96, 0xf7, 0x49, 0x59,
	0xf7, 0x1c, 0x95, 0x9a, 0xc4, 0x0e, 0xce, 0x57, 0x87, 0xcf, 0xa9, 0x69, 0x61, 0x97, 0xaa, 0x56,
	0x87, 0x7f, 0x20, 0xfd, 0x97, 0x85, 0xc4, 0x6d, 0xd7, 0x40, 0x1f, 0x41, 0x41, 0x73, 0xb0, 0x4a,
	0xb1, 0xc2, 0xf4, 0x8a, 0xc2, 0x45, 0xe1, 0x72, 0xfe, 0xfa, 0xdb, 0xa5, 0x29, 0xcd, 0x2b, 0xdd,
	0x76, 0x8d, 0x1a, 0x93, 0xdf, 0xf0, 0xf7, 0x37, 0x63, 0x72, 0x5e, 0xeb, 0x2d, 0x91, 0x03, 0xe7,
	0xbc, 0x8e, 0x7e, 0x8c, 0xae, 0x58, 0xd8, 0x6a, 0x61, 0xc7, 0x15, 0xe3, 0x4c, 0xcb, 0x7b, 0x51,
	0xb4, 0xdc, 0x65, 0x38, 0x0c, 0xf6, 0x36, 0x47, 0xd9, 0x8c, 0xc9, 0xc8, 0x1b, 0xd9, 0x45, 0x6d,
	0x40, 0x03, 0x3a, 0x55, 0xdd, 0x32, 0x6d, 0x31, 0xc1, 0x34, 0xbe, 0x3b, 0xa3, 0xc6, 0x8a, 0x8f,
	0xb1, 0x19, 0x93, 0x97, 0xbc, 0xa1, 0xbd, 0x11, 0x0f, 0x35, 0x62, 0x59, 0xd8, 0xa6, 0x62, 0x72,
	0x2e, 0x0f, 0x6b, 0x1c, 0x65, 0xc8, 0xc3, 0x60, 0x17, 0x79, 0x70, 0xae, 0xff, 0xce, 0x14, 0x55,
	0xd3, 0x88, 0x67, 0x53, 0x31, 0xc5, 0x74, 0x56, 0x66, 0xbc, 0xbb, 0x0a, 0x47, 0xd9, 0xa6, 0xba,
	0xaf, 0x56, 0x1b, 0x39, 0x40, 0x5f, 0x08, 0xb0, 0x32, 0x18, 0x59, 0x7e, 0x10, 0x44, 0x38, 0xcd,
	0xb4, 0xd7, 0x66, 0x8d, 0x30, 0xc7, 0x0a, 0x03, 0x7d, 0xde, 0x1b, 0x7f, 0x84, 0x1e, 0x08, 0xf0,
	0xda, 0x58, 0x23, 0x74, 0xac, 0x99, 0xae, 0x49, 0x6c, 0xa5, 0x43, 0xda, 0xa6, 0x76, 0x20, 0x66,
	0x98, 0x39, 0x5b, 0xf3, 0x99, 0xb3, 0x16, 0x80, 0xde, 0x61, 0x98, 0x3c, 0x34, 0x17, 0xbd, 0x67,
	0x7c, 0x86, 0xbe, 0x12, 0xe0, 0xc2, 0x58, 0x1b, 0xc3, 0xe4, 0xc8, 0x32, 0xdb, 0xd6, 0xe7, 0xb3,
	0xad, 0x97, 0x23, 0xcb, 0xde, 0xa4, 0x43, 0xf4, 0x3e, 0x24, 0xf7, 0x08, 0xc5, 0x62, 0x8e, 0x69,
	0x7c, 0x33, 0x8a, 0xc6, 0x26, 0xa1, 0x78, 0x33, 0x26, 0x33, 0x79, 0x1f, 0x07, 0xef, 0x63, 0x4d,
	0x84, 0xe8, 0x38, 0xeb, 0xfb, 0x58, 0xf3, 0x71, 0x7c, 0xf9, 0x6a, 0x0a, 0x12, 0xae, 0x67, 0x49,
	0x3f, 0x0a, 0xb0, 0x38, 0x98, 0x7d, 0x68, 0x03, 0x52, 0x3c, 0x8f, 0xfc, 0x0e, 0x54, 0xa8, 0x5e,
	0x7b, 0x72, 0xb8, 0x7a, 0xd5, 0x30, 0xe9, 0xae, 0xd7, 0x2a, 0x69, 0xc4, 0x2a, 0x73, 0x85, 0xc1,
	0x9f, 0xab, 0xae, 0xfe, 0x69, 0x99, 0x77, 0xd3, 0x8a, 0xa6, 0x55, 0x74, 0xdd, 0xc1, 0xae, 0x2b,
	0x73, 0x79, 0x54, 0x87, 0x4c, 0xaf, 0xcd, 0x24, 0x2e, 0xe7, 0xaf, 0x97, 0xa7, 0xb7, 0x96, 0xc9,
	0xc9, 0xa1, 0x3c, 0x12, 0x21, 0x13, 0x5e, 0x99, 0xdf, 0x3f, 0x72, 0x72, 0xb8, 0x94, 0xfe, 0x10,
	0xe0, 0xe5, 0xb1, 0x4d, 0xe9, 0xe4, 0xfc, 0x78, 0x05, 0x52, 0xbc, 0x25, 0xfb, 0xcd, 0x32, 0x59,
	0xcd, 0x3f, 0x39, 0x5c, 0xcd, 0x30, 0x4d, 0xf5, 0x35, 0x99, 0x9f, 0xa0, 0x26, 0x2c, 0x72, 0x53,
	0x15, 0x9e, 0x01, 0xae, 0x98, 0x98, 0xcd, 0xe3, 0x05, 0x0e, 0xc3, 0xdd, 0x71, 0xa5, 0x5f, 0x04,
	0x78, 0x69, 0x4c, 0x03, 0x3c, 0x55, 0xdf, 0x1a, 0x90, 0xb3, 0x71, 0xb7, 0xaf, 0x7b, 0xcf, 0xa4,
	0x2f, 0x6b, 0xe3, 0x2e, 0xb3, 0x5d, 0xba, 0x3f, 0x72, 0x63, 0x61, 0x8d, 0x9c, 0xa6, 0x57, 0x93,
	0x33, 0xea, 0x3b, 0x01, 0xd2, 0xfc, 0x36, 0xd0, 0x2d, 0xc8, 0xa8, 0x1c, 0x79, 0x76, 0x93, 0x42,
	0x04, 0x74, 0x13, 0x52, 0x1d, 0xd2, 0xc5, 0x0e, 0x33, 0x2a, 0x57, 0xbd, 0xf2, 0xfb, 0xe1, 0xea,
	0xa5, 0x29, 0xa0, 0xd6, 0xb0, 0x26, 0x73, 0xc1, 0xa7, 0xd8, 0xfc, 0x40, 0x80, 0xe5, 0xb1, 0x43,
	0xa4, 0xaa, 0xba, 0xf8, 0x05, 0x89, 0xeb, 0x23, 0x01, 0xc4, 0x49, 0x83, 0x0e, 0x35, 0x21, 0xd9,
	0x52, 0x5d, 0x1c, 0xb0, 0x9e, 0xea, 0x7c, 0x93, 0xd3, 0x77, 0x5a, 0x66, 0x78, 0x48, 0x83, 0x33,
	0xc3, 0xf3, 0x88, 0x53, 0x9e, 0x77, 0xa6, 0x56, 0xb1, 0x4d, 0xf5, 0xc1, 0xb1, 0x22, 0x2f, 0xea,
	0x03, 0x6b, 0xe9, 0xeb, 0x38, 0xac, 0x4c, 0x1e, 0xa2, 0x27, 0x17, 0xfe, 0x1d, 0x28, 0x84, 0x63,
	0x8c, 0xd1, 0x8c, 0xf8, 0xac, 0x78, 0x79, 0x83, 0x1b, 0xc9, 0xd8, 0xc4, 0x49, 0xd7, 0xf7, 0x97,
	0x3c, 0x17, 0x47, 0xa3, 0x71, 0xda, 0xb9, 0x28, 0xfd, 0x25, 0xc0, 0xa5, 0xe9, 0xd8, 0xc4, 0x3c,
	0xf9, 0x37, 0xde, 0xd1, 0xc9, 0xf9, 0x97, 0x38, 0xf1, 0xfc, 0x7b, 0x24, 0xc0, 0x85, 0xa7, 0x31,
	0x93, 0x17, 0x3d, 0x03, 0x27, 0xf7, 0x8c, 0xcf, 0xe0, 0xec, 0x88, 0xfb, 0xe8, 0x63, 0xc8, 0xd1,
	0x5d, 0x07, 0xbb, 0xbb, 0xa4, 0xad, 0x07, 0x17, 0x76, 0x73, 0xea, 0x68, 0xee, 0x84, 0x92, 0x83,
	0xa0, 0x9b, 0x31, 0xb9, 0x07, 0x1a, 0x92, 0xa3, 0x7f, 0x04, 0x38, 0x3f, 0xe1, 0x7b, 0xb4, 0x39,
	0x6c, 0x44, 0xb4, 0x8e, 0xde, 0x13, 0x46, 0xeb, 0x70, 0xd6, 0x32, 0x6d, 0x65, 0x8f, 0x50, 0xd3,
	0x36, 0x94, 0xae, 0x69, 0xeb, 0xa4, 0x1b, 0x34, 0xa9, 0xe5, 0x12, 0x7f, 0x3d, 0x96, 0xc2, 0xd7,
	0x63, 0x69, 0x2d, 0x78, 0x5d, 0xca, 0x67, 0x2c, 0xd3, 0x6e, 0x32, 0x91, 0x7b, 0x4c, 0x82, 0xc1,
	0xa8, 0xfb, 0x43, 0x30, 0x89, 0x67, 0xc3, 0xa8, 0xfb, 0xfd, 0x30, 0xd2, 0xdf, 0x9c, 0x10, 0xde,
	0x71, 0x48, 0x87, 0xb8, 0x98, 0x95, 0x6c, 0x13, 0x16, 0x06, 0x9f, 0x37, 0x33, 0x67, 0x51, 0xc1,
	0xe8, 0x7f, 0xc6, 0x6c, 0x41, 0xae, 0xc3, 0xd5, 0x04, 0x0c, 0x71, 0x26, 0xcc, 0x1e, 0xc6, 0xe4,
	0x3c, 0x42, 0xcb, 0x90, 0xf5, 0x59, 0xaf, 0x62, 0x93, 0x2e, 0x7b, 0x10, 0x66, 0xe5, 0x8c, 0xbf,
	0x6e, 0x90, 0xae, 0x74, 0x24, 0x40, 0x26, 0x20, 0xd9, 0xe8, 0x0a, 0x64, 0x39, 0x9a, 0xda, 0x66,
	0x4e, 0x26, 0xab, 0x8b, 0x4f, 0x0e, 0x57, 0xe1, 0x4e, 0xb0, 0x57, 0x5f, 0x93, 0x8f, 0xcf, 0x51,
	0x1d, 0xd2, 0x3e, 0x21, 0x9f, 0xc7, 0xf4, 0x00, 0x00, 0x6d, 0x40, 0x5a, 0xdb, 0x25, 0xa6, 0x86,
	0x99, 0xd9, 0x8b, 0x11, 0x58, 0x63, 0x8d, 0x89, 0xc9, 0x81, 0x78, 0x7f, 0x00, 0x92, 0x83, 0x85,
	0xf4, 0x39, 0xf7, 0xd2, 0x7f, 0x02, 0x44, 0xf5, 0xd2, 0x35, 0x0d, 0x3b, 0x60, 0x2d, 0xb3, 0x79,
	0xc9, 0x01, 0xa4, 0x6f, 0x05, 0x58, 0x08, 0x08, 0x3a, 0x55, 0x75, 0x95, 0xaa, 0xbd, 0x16, 0x2e,
	0x4c, 0xa4, 0x13, 0xc7, 0x9d, 0x2b, 0x3e, 0x67, 0xe7, 0x9a, 0x9c, 0x1b, 0x22, 0x64, 0xf6, 0xb0,
	0xe3, 0x97, 0x36, 0x0b, 0x5a, 0x52, 0x0e, 0x97, 0xd2, 0x4f, 0x02, 0xe4, 0xfb, 0x9e, 0x14, 0xd3,
	0xd8, 0x5b, 0x87, 0x34, 0x67, 0xf0, 0x73, 0xc4, 0x8b, 0x03, 0xa0, 0x2a, 0xa4, 0xbb, 0xd8, 0x34,
	0x76, 0x03, 0x83, 0x23, 0xb5, 0x97, 0x40, 0x52, 0xfa, 0x57, 0x00, 0xb1, 0x7f, 0x20, 0x84, 0xa1,
	0x7f, 0xae, 0x75, 0x3d, 0x05, 0x4b, 0x3c, 0xbe, 0xd6, 0xc4, 0xc9, 0x5d, 0xeb, 0x50, 0xc6, 0xff,
	0x2a, 0xc0, 0xf9, 0x6d, 0xaa, 0x8f, 0xf3, 0x1e, 0xdd, 0x1d, 0x98, 0xf6, 0xd3, 0xff, 0x4e, 0x33,
	0x29, 0x94, 0xa7, 0x49, 0x36, 0x7f, 0x88, 0x43, 0x21, 0x2c, 0xd5, 0xe7, 0x7a, 0x8d, 0x7d, 0xa1,
	0x8d, 0x0f, 0x56, 0xcc, 0x40, 0xe3, 0x4e, 0x9c, 0x40, 0xe3, 0xbe, 0x01, 0x05, 0xd7, 0x6b, 0x59,
	0x26, 0xa5, 0x58, 0x57, 0xd4, 0xf0, 0x37, 0xbb, 0x95, 0x91, 0xb1, 0xb5, 0x13, 0xfe, 0x76, 0x2a,
	0xe7, 0x8f, 0xbf, 0xaf, 0x50, 0xf4, 0x6a, 0x18, 0x81, 0xb0, 0x8e, 0x53, 0xac, 0x8e, 0xb9, 0x3b,
	0xcd, 0xa0, 0x98, 0xbf, 0x8f, 0x43, 0x6a, 0x47, 0x6d, 0xb7, 0x0f, 0xd0, 0x06, 0xe4, 0x0e, 0xb0,
	0xab, 0xf4, 0x82, 0x15, 0xad, 0xb6, 0xb2, 0x07, 0xd8, 0xad, 0xb1, 0x08, 0xad, 0x43, 0xd6, 0x26,
	0x4a, 0x8f, 0x09, 0x45, 0xc3, 0xc9, 0xd8, 0xa4, 0x16, 0xcc, 0xc1, 0x05, 0xb5, 0xe5, 0x52, 0xd5,
	0xb4, 0x03, 0xac, 0xe8, 0xf5, 0x5e, 0x08, 0x00, 0x38, 0x60, 0x1d, 0x60, 0x0f, 0xd3, 0xd0, 0xb2,
	0x64, 0x74, 0x72, 0xe2, 0x4b, 0x33, 0x28, 0xe9, 0x7e, 0x1c, 0x92, 0x91, 0x47, 0xe3, 0x06, 0xa4,
	0xd8, 0x64, 0x9b, 0xa3, 0x69, 0x33, 0xf9, 0x53, 0x18, 0x8c, 0x23, 0xa9, 0x97, 0x8a, 0x94, 0x7a,
	0x57, 0x6e, 0x40, 0x9a, 0xab, 0x42, 0x79, 0xc8, 0xdc, 0x6d, 0xdc, 0x6a, 0x6c, 0xdd, 0x6b, 0x2c,
	0xc5, 0x50, 0x1a, 0xe2, 0x8d, 0xad, 0x25, 0x01, 0x65, 0x20, 0xf1, 0xc1, 0xfa, 0xf6, 0x52, 0xdc,
	0x3f, 0xad, 0x54, 0xb7, 0x77, 0x2a, 0xf5, 0xc6, 0x52, 0x02, 0x65, 0x21, 0xd9, 0x5c, 0xdf, 0xd9,
	0x5a, 0x4a, 0x56, 0x6b, 0x3f, 0x3f, 0x2e, 0x0a, 0x0f, 0x1f, 0x17, 0x85, 0x3f, 0x1f, 0x17, 0x85,
	0x6f, 0x8e, 0x8a, 0xb1, 0x87, 0x47, 0xc5, 0xd8, 0x6f, 0x47, 0xc5, 0xd8, 0x87, 0x6f, 0x8c, 0x06,
	0x2c, 0x70, 0xba, 0x7c, 0xec, 0x74, 0x99, 0x39, 0xdd, 0x4a, 0x33, 0x23, 0xdf, 0xfa, 0x3f, 0x00,
	0x00, 0xff, 0xff, 0x5d, 0xf4, 0x10, 0x59, 0xd7, 0x18, 0x00, 0x00,
}

func (m *Msg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Msg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sum != nil {
		{
			size := m.Sum.Size()
			i -= size
			if _, err := m.Sum.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Msg_CreateGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_CreateGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateGroup != nil {
		{
			size, err := m.CreateGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Msg_UpdateGroupMembers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_UpdateGroupMembers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateGroupMembers != nil {
		{
			size, err := m.UpdateGroupMembers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Msg_UpdateGroupAdmin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_UpdateGroupAdmin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateGroupAdmin != nil {
		{
			size, err := m.UpdateGroupAdmin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Msg_UpdateGroupComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_UpdateGroupComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateGroupComment != nil {
		{
			size, err := m.UpdateGroupComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Msg_CreateGroupAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_CreateGroupAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateGroupAccount != nil {
		{
			size, err := m.CreateGroupAccount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Msg_UpdateGroupAccountAdmin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_UpdateGroupAccountAdmin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateGroupAccountAdmin != nil {
		{
			size, err := m.UpdateGroupAccountAdmin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Msg_UpdateGroupAccountDecisionPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_UpdateGroupAccountDecisionPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateGroupAccountDecisionPolicy != nil {
		{
			size, err := m.UpdateGroupAccountDecisionPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Msg_UpdateGroupAccountComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_UpdateGroupAccountComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateGroupAccountComment != nil {
		{
			size, err := m.UpdateGroupAccountComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Msg_Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Vote != nil {
		{
			size, err := m.Vote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Msg_Exec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_Exec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Exec != nil {
		{
			size, err := m.Exec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *MsgCreateGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateGroupMembers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateGroupMembers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateGroupMembers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MemberUpdates) > 0 {
		for iNdEx := len(m.MemberUpdates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MemberUpdates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Group != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateGroupAdmin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateGroupAdmin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateGroupAdmin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewAdmin) > 0 {
		i -= len(m.NewAdmin)
		copy(dAtA[i:], m.NewAdmin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NewAdmin)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Group != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateGroupComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateGroupComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateGroupComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Group != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Power != nil {
		{
			size := m.Power.Size()
			i -= size
			if _, err := m.Power.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateGroupAccountBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateGroupAccountBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateGroupAccountBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Group != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateGroupAccountStd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateGroupAccountStd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateGroupAccountStd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DecisionPolicy != nil {
		{
			size, err := m.DecisionPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateGroupAccountAdmin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateGroupAccountAdmin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateGroupAccountAdmin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewAdmin) > 0 {
		i -= len(m.NewAdmin)
		copy(dAtA[i:], m.NewAdmin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NewAdmin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.GroupAcount) > 0 {
		i -= len(m.GroupAcount)
		copy(dAtA[i:], m.GroupAcount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupAcount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateGroupAccountBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateGroupAccountBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateGroupAccountBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Group != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateGroupAccountDecisionPolicyStd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateGroupAccountDecisionPolicyStd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateGroupAccountDecisionPolicyStd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DecisionPolicy != nil {
		{
			size, err := m.DecisionPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateGroupAccountComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateGroupAccountComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateGroupAccountComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.GroupAcount) > 0 {
		i -= len(m.GroupAcount)
		copy(dAtA[i:], m.GroupAcount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupAcount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StdDecisionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StdDecisionPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StdDecisionPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sum != nil {
		{
			size := m.Sum.Size()
			i -= size
			if _, err := m.Sum.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StdDecisionPolicy_Threshold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StdDecisionPolicy_Threshold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Threshold != nil {
		{
			size, err := m.Threshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ThresholdDecisionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThresholdDecisionPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdDecisionPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxVotingWindow != nil {
		{
			size, err := m.MaxVotingWindow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MinVotingWindow != nil {
		{
			size, err := m.MinVotingWindow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Threshold != nil {
		{
			size := m.Threshold.Size()
			i -= size
			if _, err := m.Threshold.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposeBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposeBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposeBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExecNow {
		i--
		if m.ExecNow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Proposers) > 0 {
		for iNdEx := len(m.Proposers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Proposers[iNdEx])
			copy(dAtA[i:], m.Proposers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Proposers[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.GroupAccount) > 0 {
		i -= len(m.GroupAccount)
		copy(dAtA[i:], m.GroupAccount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupAccount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x22
	}
	if m.Choice != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Choice))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Voters) > 0 {
		for iNdEx := len(m.Voters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Voters[iNdEx])
			copy(dAtA[i:], m.Voters[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Voters[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Proposal != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Proposal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgExec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgExec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgExec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0x12
	}
	if m.Proposal != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Proposal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GroupMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if m.Group != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GroupMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Weight != nil {
		{
			size := m.Weight.Size()
			i -= size
			if _, err := m.Weight.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Member) > 0 {
		i -= len(m.Member)
		copy(dAtA[i:], m.Member)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Member)))
		i--
		dAtA[i] = 0x12
	}
	if m.Group != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GroupAccountMetadataBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupAccountMetadataBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupAccountMetadataBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Group != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GroupAccount) > 0 {
		i -= len(m.GroupAccount)
		copy(dAtA[i:], m.GroupAccount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupAccount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StdGroupAccountMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StdGroupAccountMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StdGroupAccountMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DecisionPolicy != nil {
		{
			size, err := m.DecisionPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GroupVersion))
		i--
		dAtA[i] = 0x28
	}
	if m.SubmittedAt != nil {
		{
			size, err := m.SubmittedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Proposers) > 0 {
		for iNdEx := len(m.Proposers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Proposers[iNdEx])
			copy(dAtA[i:], m.Proposers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Proposers[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.GroupAccount) > 0 {
		i -= len(m.GroupAccount)
		copy(dAtA[i:], m.GroupAccount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupAccount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tally) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tally) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tally) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VetoCount != nil {
		{
			size := m.VetoCount.Size()
			i -= size
			if _, err := m.VetoCount.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.AbstainCount != nil {
		{
			size := m.AbstainCount.Size()
			i -= size
			if _, err := m.AbstainCount.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.NoCount != nil {
		{
			size := m.NoCount.Size()
			i -= size
			if _, err := m.NoCount.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.YesCount != nil {
		{
			size := m.YesCount.Size()
			i -= size
			if _, err := m.YesCount.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Vote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubmittedAt != nil {
		{
			size, err := m.SubmittedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x22
	}
	if m.Choice != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Choice))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0x12
	}
	if m.Proposal != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Proposal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Msg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != nil {
		n += m.Sum.Size()
	}
	return n
}

func (m *Msg_CreateGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateGroup != nil {
		l = m.CreateGroup.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Msg_UpdateGroupMembers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateGroupMembers != nil {
		l = m.UpdateGroupMembers.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Msg_UpdateGroupAdmin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateGroupAdmin != nil {
		l = m.UpdateGroupAdmin.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Msg_UpdateGroupComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateGroupComment != nil {
		l = m.UpdateGroupComment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Msg_CreateGroupAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateGroupAccount != nil {
		l = m.CreateGroupAccount.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Msg_UpdateGroupAccountAdmin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateGroupAccountAdmin != nil {
		l = m.UpdateGroupAccountAdmin.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Msg_UpdateGroupAccountDecisionPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateGroupAccountDecisionPolicy != nil {
		l = m.UpdateGroupAccountDecisionPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Msg_UpdateGroupAccountComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateGroupAccountComment != nil {
		l = m.UpdateGroupAccountComment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Msg_Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vote != nil {
		l = m.Vote.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Msg_Exec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exec != nil {
		l = m.Exec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *MsgCreateGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgUpdateGroupMembers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovTypes(uint64(m.Group))
	}
	if len(m.MemberUpdates) > 0 {
		for _, e := range m.MemberUpdates {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *MsgUpdateGroupAdmin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovTypes(uint64(m.Group))
	}
	l = len(m.NewAdmin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgUpdateGroupComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovTypes(uint64(m.Group))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Power != nil {
		l = m.Power.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgCreateGroupAccountBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovTypes(uint64(m.Group))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgCreateGroupAccountStd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DecisionPolicy != nil {
		l = m.DecisionPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgUpdateGroupAccountAdmin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.GroupAcount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NewAdmin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgUpdateGroupAccountBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovTypes(uint64(m.Group))
	}
	return n
}

func (m *MsgUpdateGroupAccountDecisionPolicyStd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DecisionPolicy != nil {
		l = m.DecisionPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgUpdateGroupAccountComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.GroupAcount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StdDecisionPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != nil {
		n += m.Sum.Size()
	}
	return n
}

func (m *StdDecisionPolicy_Threshold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Threshold != nil {
		l = m.Threshold.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ThresholdDecisionPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Threshold != nil {
		l = m.Threshold.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MinVotingWindow != nil {
		l = m.MinVotingWindow.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MaxVotingWindow != nil {
		l = m.MaxVotingWindow.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgProposeBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupAccount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Proposers) > 0 {
		for _, b := range m.Proposers {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExecNow {
		n += 2
	}
	return n
}

func (m *MsgVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != 0 {
		n += 1 + sovTypes(uint64(m.Proposal))
	}
	if len(m.Voters) > 0 {
		for _, b := range m.Voters {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Choice != 0 {
		n += 1 + sovTypes(uint64(m.Choice))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MsgExec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != 0 {
		n += 1 + sovTypes(uint64(m.Proposal))
	}
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GroupMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != 0 {
		n += 1 + sovTypes(uint64(m.Group))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	return n
}

func (m *GroupMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != 0 {
		n += 1 + sovTypes(uint64(m.Group))
	}
	l = len(m.Member)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Weight != nil {
		l = m.Weight.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GroupAccountMetadataBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupAccount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovTypes(uint64(m.Group))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StdGroupAccountMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DecisionPolicy != nil {
		l = m.DecisionPolicy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ProposalBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupAccount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Proposers) > 0 {
		for _, b := range m.Proposers {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SubmittedAt != nil {
		l = m.SubmittedAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.GroupVersion != 0 {
		n += 1 + sovTypes(uint64(m.GroupVersion))
	}
	return n
}

func (m *Tally) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.YesCount != nil {
		l = m.YesCount.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NoCount != nil {
		l = m.NoCount.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AbstainCount != nil {
		l = m.AbstainCount.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VetoCount != nil {
		l = m.VetoCount.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proposal != 0 {
		n += 1 + sovTypes(uint64(m.Proposal))
	}
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Choice != 0 {
		n += 1 + sovTypes(uint64(m.Choice))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SubmittedAt != nil {
		l = m.SubmittedAt.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Msg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Msg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Msg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgCreateGroup{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Msg_CreateGroup{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateGroupMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgUpdateGroupMembers{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Msg_UpdateGroupMembers{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateGroupAdmin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgUpdateGroupAdmin{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Msg_UpdateGroupAdmin{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateGroupComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgUpdateGroupComment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Msg_UpdateGroupComment{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateGroupAccount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgCreateGroupAccountStd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Msg_CreateGroupAccount{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateGroupAccountAdmin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgUpdateGroupAccountAdmin{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Msg_UpdateGroupAccountAdmin{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateGroupAccountDecisionPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgUpdateGroupAccountDecisionPolicyStd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Msg_UpdateGroupAccountDecisionPolicy{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateGroupAccountComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgUpdateGroupAccountComment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Msg_UpdateGroupAccountComment{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Msg_Vote{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgExec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Msg_Exec{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &Member{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateGroupMembers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateGroupMembers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateGroupMembers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberUpdates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemberUpdates = append(m.MemberUpdates, &Member{})
			if err := m.MemberUpdates[len(m.MemberUpdates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateGroupAdmin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateGroupAdmin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateGroupAdmin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAdmin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewAdmin = append(m.NewAdmin[:0], dAtA[iNdEx:postIndex]...)
			if m.NewAdmin == nil {
				m.NewAdmin = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateGroupComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateGroupComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateGroupComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.Power = &v
			if err := m.Power.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateGroupAccountBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateGroupAccountBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateGroupAccountBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateGroupAccountStd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateGroupAccountStd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateGroupAccountStd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &MsgCreateGroupAccountBase{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DecisionPolicy == nil {
				m.DecisionPolicy = &StdDecisionPolicy{}
			}
			if err := m.DecisionPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateGroupAccountAdmin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateGroupAccountAdmin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateGroupAccountAdmin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAcount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupAcount = append(m.GroupAcount[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupAcount == nil {
				m.GroupAcount = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAdmin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewAdmin = append(m.NewAdmin[:0], dAtA[iNdEx:postIndex]...)
			if m.NewAdmin == nil {
				m.NewAdmin = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateGroupAccountBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateGroupAccountBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateGroupAccountBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateGroupAccountDecisionPolicyStd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateGroupAccountDecisionPolicyStd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateGroupAccountDecisionPolicyStd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &MsgUpdateGroupAccountBase{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DecisionPolicy == nil {
				m.DecisionPolicy = &StdDecisionPolicy{}
			}
			if err := m.DecisionPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateGroupAccountComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateGroupAccountComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateGroupAccountComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAcount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupAcount = append(m.GroupAcount[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupAcount == nil {
				m.GroupAcount = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StdDecisionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StdDecisionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StdDecisionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ThresholdDecisionPolicy{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &StdDecisionPolicy_Threshold{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThresholdDecisionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThresholdDecisionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThresholdDecisionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.Threshold = &v
			if err := m.Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinVotingWindow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinVotingWindow == nil {
				m.MinVotingWindow = &types.Duration{}
			}
			if err := m.MinVotingWindow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxVotingWindow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxVotingWindow == nil {
				m.MaxVotingWindow = &types.Duration{}
			}
			if err := m.MaxVotingWindow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposeBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposeBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposeBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAccount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupAccount = append(m.GroupAccount[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupAccount == nil {
				m.GroupAccount = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposers = append(m.Proposers, make([]byte, postIndex-iNdEx))
			copy(m.Proposers[len(m.Proposers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecNow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExecNow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			m.Proposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposal |= ProposalID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voters", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voters = append(m.Voters, make([]byte, postIndex-iNdEx))
			copy(m.Voters[len(m.Voters)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Choice", wireType)
			}
			m.Choice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Choice |= Choice(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgExec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgExec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgExec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			m.Proposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposal |= ProposalID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = append(m.Signer[:0], dAtA[iNdEx:postIndex]...)
			if m.Signer == nil {
				m.Signer = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Member = append(m.Member[:0], dAtA[iNdEx:postIndex]...)
			if m.Member == nil {
				m.Member = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.Weight = &v
			if err := m.Weight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupAccountMetadataBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupAccountMetadataBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupAccountMetadataBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAccount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupAccount = append(m.GroupAccount[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupAccount == nil {
				m.GroupAccount = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = append(m.Admin[:0], dAtA[iNdEx:postIndex]...)
			if m.Admin == nil {
				m.Admin = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StdGroupAccountMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StdGroupAccountMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StdGroupAccountMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &GroupAccountMetadataBase{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DecisionPolicy == nil {
				m.DecisionPolicy = &StdDecisionPolicy{}
			}
			if err := m.DecisionPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAccount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupAccount = append(m.GroupAccount[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupAccount == nil {
				m.GroupAccount = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposers = append(m.Proposers, make([]byte, postIndex-iNdEx))
			copy(m.Proposers[len(m.Proposers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubmittedAt == nil {
				m.SubmittedAt = &types.Timestamp{}
			}
			if err := m.SubmittedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupVersion", wireType)
			}
			m.GroupVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tally) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tally: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tally: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YesCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.YesCount = &v
			if err := m.YesCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.NoCount = &v
			if err := m.NoCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbstainCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.AbstainCount = &v
			if err := m.AbstainCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VetoCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.VetoCount = &v
			if err := m.VetoCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			m.Proposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposal |= ProposalID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = append(m.Voter[:0], dAtA[iNdEx:postIndex]...)
			if m.Voter == nil {
				m.Voter = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Choice", wireType)
			}
			m.Choice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Choice |= Choice(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubmittedAt == nil {
				m.SubmittedAt = &types.Timestamp{}
			}
			if err := m.SubmittedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
